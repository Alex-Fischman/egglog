use crate::ast::*;
use crate::*;

grammar;

// lexer
match {
    r"\s*" => { }, // skip whitespace
    r";[^\n\r]*[\n\r]*" => { }, // skip ; comments
    _
}

pub Program: Vec<Command> = { (Command)* => <> }

List<T>: Vec<T> = { 
    "(" <T*> ")" => <>,
}

MergeFn: MergeFn = {
    "(" "merge" <var1:Ident> <var2:Ident> <expr:Expr> ")" => MergeFn { vars: (var1, var2), expr }
}

Command: Command = {
    "(" "datatype" <name:Ident> <variants:(Variant)*> ")" => Command::Datatype { <> },
    "(" "function" <name:Ident> <schema:Schema> <merge:MergeFn?> ")" => Command::Function { name, schema, merge },
    "(" "relation" <name:Ident> <types:List<Type>> ")" => Command::Function { name, schema: Schema::relation(types), merge: None },
    "(" "rule" <name:Name?> <query:Query> <actions:List<Action>> ")" => Command::Rule(name, Rule {query, actions}),
    "(" "rewrite" <name:Name?> <lhs:Expr> <rhs:Expr> ")" => Command::Rule(name, Rule::rewrite(lhs, rhs)),
    <Action> => Command::Action(<>),
    "(" "run" <Num> ")" => Command::Run(<>.try_into().unwrap()),
    "(" "extract" <Expr> ")" => Command::Extract(<>),
    "(" "check-eq" <(Expr)+> ")" => Command::CheckEq(<>),
}

Name: Symbol = { "[" <Ident> "]" => <> }

Action: Action = {
    "(" "define" <Ident> <Expr> ")" => Action::Define(<>),
    "(" "union" <Expr*> ")" => Action::Union(<>),
    "(" "assert" <Expr*> ")" => Action::Assert(<>),
    "(" "set" <NodeExpr> <Expr+> ")" => Action::Set(<>),
}

Schema: Schema = {
    <types:List<Type>> <output:Type> => Schema { input: types, output }
}

Query: Query = {
    <groups:List<List<Expr>>> => Query::from_groups(groups)
}

Expr: Expr = {
    <Num> => Expr::leaf(<>),
    <Bool> => Expr::leaf(<>),
    <Ident> => Expr::Var(<>),
    <NodeExpr> => <>,
    "(" <head:PrimitiveSymbol> <tail:(Expr)+> ")" => Expr::Node(head, tail),
};

NodeExpr: Expr = {
    "(" <head:Ident> <tail:(Expr)*> ")" => Expr::Node(head, tail),
}


ExprList: Vec<Expr> = { "(" <sexps:(Expr)*> ")" => sexps }

Variant: Variant = {
    "(" <name:Ident> <types:(Type)*> ")" => Variant { <> },
}

Type: Type = { 
    "Int" => Type::Int,
    <Ident> => Type::Sort(<>),
}

Num: i64 = <s:r"(-)?[0-9]+"> => s.parse().unwrap();
Bool: bool = {
    "true" => true,
    "false" => false,
}
Ident: Symbol = <s:r"[[:alpha:]][\w-]*"> => s.parse().unwrap();
PrimitiveSymbol: Symbol = <r"[+*/-]"> => Symbol::from(<>);